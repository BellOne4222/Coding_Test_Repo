# 참고 : https://chancoding.tistory.com/49

# 테스트 케이스의 개수를 입력받음
t = int(input())

# 각 테스트 케이스에 대한 반복
for _ in range(t):
    # 왼쪽 스택과 오른쪽 스택을 초기화
    l_list = []
    r_list = []

    # 사용자로부터 문자열을 입력받음
    data = input()

    # 입력받은 문자열을 문자 단위로 처리
    for i in data:
        # 입력 문자가 '-'인 경우, 왼쪽 스택에서 문자를 제거
        if i == '-':
            # 왼쪽 스택이 비어있지 않을 때만 제거
            if l_list:
                l_list.pop()
        # 입력 문자가 '<'인 경우, 왼쪽 스택에서 오른쪽 스택으로 문자 이동
        elif i == '<':
            # 왼쪽 스택이 비어있지 않을 때만 이동
            if l_list:
                r_list.append(l_list.pop())
        # 입력 문자가 '>'인 경우, 오른쪽 스택에서 왼쪽 스택으로 문자 이동
        elif i == '>':
            # 오른쪽 스택이 비어있지 않을 때만 이동
            if r_list:
                l_list.append(r_list.pop())
        # 그 외의 경우, 입력 문자를 왼쪽 스택에 추가
        else:
            l_list.append(i)

    # 왼쪽 스택에 남은 문자와 오른쪽 스택의 역순 문자를 결합하여 결과 문자열 생성
    l_list.extend(reversed(r_list))
    
    # 결과 문자열 출력
    print(''.join(l_list))


# 전체 테스트 케이스가 1,000,000 개의 문자열이 입력될 수 있습니다. 상당히 많은 입력이 예정되어 있으므로 시간 복잡도를 고려해서 해결하는 것이 관건일 것입니다.
# 커서의 위치를 index = 0으로 둔 다음 앞뒤로 움직일 때마다 앞 뒤로 움직이는 방식으로 진행하는 방식을 가장 먼저 생각할 수 있습니다. 즉, 시뮬레이션 방식입니다. 하지만 그렇게 구현하면 시간 복잡도가 높아져서 시간이 오래 걸립니다.
# 문자열을 그대로 두고 커서를 움직이는 것 => 일반적인 생각 => 문제가 해결되지 않는다 => 발상의 전환이 필요하다.
# 커서를 그대로 두고 문자열을 움직이도록 하는 것을 생각할 수 있습니다. 입력된 문자를 리스트에 담도록 합니다. 만약 커서를 움직여서 왼쪽으로 이동하게 되면 리스트 요 소드를 pop시킨 후 다른 리스트에 담아 놓으면 됩니다. 즉 커서를 기준으로 양쪽에 리스트가 있다고 생각하면 됩니다.

# 위 그림처럼 커서를 왼쪽으로 움직이면 리스트의 요소가 오른쪽 리스트로 옮겨가는 방식입니다.
# -가 입력되면 왼쪽 리스트의 마지막 요소를 제거하면 됩니다.
# 전체 플로우데로 소스코드를 작성하되 요소가 없는 경우(pop을 시킬 수 없는 경우)에 대해서 조건문만 잘 넣어주면 되겠습니다.
# 리스트 방식으로 사용하면 insert(0, left.pop())으로 생각할 수도 있습니다. 아니면, 위의 소스코드처럼 stack방식을 사용해서 그림의 문자P를 가장 안쪽까지 넣어주고 연결할 때, reversed해주는 방식으로 하면 조금 더 효율적일 것입니다.