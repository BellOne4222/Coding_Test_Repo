def solution(x, y, n):
    # x와 y가 이미 같은 경우, 연산이 필요하지 않으므로 0을 반환
    if x == y:
        return 0

    # dp 배열 초기화, dp[i]는 i를 만들기 위한 최소 연산 횟수를 저장
    # 여기서는 초기값을 10^9로 설정
    # 초기값은 충분히 큰 값을 사용하여 x를 y로 변환하기 위해 필요한 연산 횟수의 최댓값보다 크거나 float['int']
    dp = [10**9] * (y + 1)
    dp[x] = 0  # 초기 값 설정: x를 만들기 위한 연산 횟수는 0

    # x부터 y까지 반복하면서 dp 배열 업데이트
    for i in range(x, y + 1):
        # dp[i]가 초기값(10^9)이면 아무 작업을 수행하지 않음
        if dp[i] == 10**9:
            continue

        # i에 n을 더한 값이 y 이하이면서 해당 연산 횟수가 현재 저장된 값보다 작을 경우 업데이트
        if i + n <= y:
            dp[i + n] = min(dp[i + n], dp[i] + 1)

        # i를 2배한 값이 y 이하이면서 해당 연산 횟수가 현재 저장된 값보다 작을 경우 업데이트
        if i * 2 <= y:
            dp[i * 2] = min(dp[i * 2], dp[i] + 1)

        # i를 3배한 값이 y 이하이면서 해당 연산 횟수가 현재 저장된 값보다 작을 경우 업데이트
        if i * 3 <= y:
            dp[i * 3] = min(dp[i * 3], dp[i] + 1)

    # dp 배열의 마지막 값이 초기값(10^9)인 경우, y를 만들 수 없다는 의미이므로 -1을 반환
    if dp[y] == 10**9:
        return -1

    # dp 배열의 마지막 값이 초기값이 아니라면, y를 만들기 위한 최소 연산 횟수를 반환
    return dp[y]