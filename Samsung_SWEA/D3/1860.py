# 1860 진기의 최고급 붕어빵

# 진기는 붕어빵 가게를 운영하고 있다.

# 진기가 파는 붕어빵은 그냥 붕어빵이 아니라 겉은 바삭! 속은 말랑! 한입 물면 팥 앙금이 주르륵 흘러 입안에서 춤을 추며,

# 절로 어릴 적 호호 불며 먹었던 뜨거운 붕어빵의 추억이 떠올라 눈물이 나오게 되는 최고급 붕어빵이다.

# 진기는 이런 붕어빵을 보통 사람들에게는 팔지 않는다.

# 그는 무조건 예약제로만 손님을 받으며, 예약을 하려는 손님들은 진기의 까다로운 자격 검증에서 합격해야만 붕어빵을 맛 볼 자격을 얻는다.

# 그래서 오늘은 N명의 사람이 자격을 얻었다.

# 진기는 0초부터 붕어빵을 만들기 시작하며, M초의 시간을 들이면 K개의 붕어빵을 만들 수 있다.

# 서빙은 진기가 하는 것이 아니기 때문에, 붕어빵이 완성되면 어떤 시간 지연도 없이 다음 붕어빵 만들기를 시작할 수 있다.

# 0초 이후에 손님들이 언제 도착하는지 주어지면, 모든 손님들에게 기다리는 시간없이 붕어빵을 제공할 수 있는지 판별하는 프로그램을 작성하라.


# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫 번째 줄에는 세 자연수 N, M, K(1 ≤ N, M, K ≤ 100)가 공백으로 구분되어 주어진다.

# 두 번째 줄에는 N개의 정수가 공백으로 구분되어 주어지며,

# 각 정수는 각 사람이 언제 도착하는지를 초 단위로 나타낸다. 각 수는 0이상 11,111이하이다.


# [출력]

# 각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,

# 모든 손님에 대해 기다리는 시간이 없이 붕어빵을 제공할 수 있으면 “Possible”을, 아니라면 “Impossible”을 출력한다.

T = int(input())
for test_case in range(1, T+1):
    N, M, K = map(int, input().split())
    arrive = list(map(int, input().split()))
    arrive.sort() # M으로 나누기 위해서 정렬

    result = "Possible"
    
    for i in range(N):
        carp = (arrive[i] // M) * K - (i+1) # 도착한 시간까지 만들어진 붕어빵의 개수: (x // M) * K - 이미 사간 개수
        if carp < 0:
            result = "Impossible"
            break

    print("#{} {}".format(test_case, result))

# 무조건 손님 1명한테는 1개의 붕어빵을 판매하기 때문에 하나씩 카운트를 해주면 된다.

# 0초부터 M초 마다 붕어를 만듦으로 M, 2M, 3M, ... 초 마다 K, 2K, 3K의 붕어빵이 남는다.

# 그렇다면 일반적으로 x초 일때의 붕어 생산량과 그 전에 사간 사람의 수를 빼면 x초의 붕어빵 재고를 알 수 있다.

# 재고가 음수가 되면 다 팔렸다는 뜻이므로 Impossible 을 출력하면 된다.

# 손님이 온 시간을 arrive_time 이라는 리스트에 담아 올림차순으로 소팅을 해준 후,

# 소팅한 arrive_time 리스트를 순회하며 가장 적은 시간부터 순서대로 체킹을 했다.

# 일반적으로 x초까지 만들어진 붕어 개수는 (x // M) * K 이다.

# 왜냐하면 단위 시간(M)으로 나눈 몫만큼 만들 수 있고, 그때마다 K개를 만들기 때문이다.

# 인당 1개씩 구매하기 때문에 (x // M) * K 에서 인덱스+1 만큼 빼주면 된다.