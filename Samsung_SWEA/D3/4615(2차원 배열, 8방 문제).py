# 4615. 재미있는 오셀로 게임

# 오셀로라는 게임은 흑돌과 백돌을 가진 사람이 번갈아가며 보드에 돌을 놓아서 최종적으로 보드에 자신의 돌이 많은 사람이 이기는 게임이다.

# 보드는 4x4, 6x6, 8x8(가로, 세로 길이) 크기를 사용한다. 6x6 보드에서 게임을 할 때, 처음에 플레이어는 다음과 같이 돌을 놓고 시작한다(B : 흑돌, W : 백돌).

# 4x4, 8x8 보드에서도 동일하게 정가운데에 아래와 같이 배치하고 시작한다.



# 그리고 흑, 백이 번갈아가며 돌을 놓는다.

# 처음엔 흑부터 시작하는데 이 때 흑이 돌을 놓을 수 있는 곳은 다음과 같이 4군데이다.



# 플레이어는 빈공간에 돌을 놓을 수 있다.

# 단, 자신이 놓을 돌과 자신의 돌 사이에 상대편의 돌이 있을 경우에만 그 곳에 돌을 놓을 수 있고, 그 때의 상대편의 돌은 자신의 돌로 만들 수 있다.

# (여기에서 "사이"란 가로/세로/대각선을 의미한다.)

# (2, 3) 위치에 흑돌을 놓은 후의 보드는 다음과 같다.



# 이런 식으로 번갈아가며 흑, 백 플레이어가 돌을 놓는다.

# 만약 돌을 놓을 곳이 없다면 상대편 플레이어가 다시 돌을 놓는다.

# 보드에 빈 곳이 없거나 양 플레이어 모두 돌을 놓을 곳이 없으면 게임이 끝나고 그 때 보드에 있는 돌의 개수가 많은 플레이어가 승리하게 된다.


#  [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫 번째 줄에는 보드의 한 변의 길이 N과 플레이어가 돌을 놓는 횟수 M이 주어진다. N은 4, 6, 8 중 하나이다.

# 그 다음 M줄에는 돌을 놓을 위치와 돌의 색이 주어진다.

# 돌의 색이 1이면 흑돌, 2이면 백돌이다.

# 만약 3 2 1이 입력된다면 (3, 2) 위치에 흑돌을 놓는 것을 의미한다.

# 돌을 놓을 수 없는 곳은 입력으로 주어지지 않는다.

#  [출력]

# 각 테스트 케이스마다 게임이 끝난 후 보드 위의 흑돌, 백돌의 개수를 출력한다.

# 흑돌이 30개, 백돌이 34인 경우 30 34를 출력한다.

# 1. 초기 돌 놓기
# 2. 입력 받은 좌표에 돌 놓기 (8방향 뻗어나가면서 처리)
# 3. 2번을 범위 내와 밖으로 나눠서 처리
# 4. 범위 밖은 아무일도 일어나지 않고 return
# 5. 범위 내는 (1) 빈칸이 0이면 끝내고 다음방향 (2) 놓은 돌과 다른 돌이면 뒤집을 후보에 추가(reverse 배열) 하고 다음 방향 (3) 같은 돌이면 뒤집을 후보들 다 뒤집고 다음 방향

# 1
T = int(input())
for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    arr = [[0]*(N+1) for _ in range(N+1)] # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
    m = N//2 # 중앙에 놓고 시작한다고 해서 중앙 좌표
    arr[m][m] = arr[m+1][m+1] = 2 # 중앙에 놓는 백 돌
    arr[m][m+1] = arr[m+1][m] = 1 # 중앙에 놓는 흑 돌
    # 3
    for _ in range(M): # 초기 돌 셋팅
        si, sj, d = map(int, input().split()) # 시작 i,j, 돌 색깔
        arr[si][sj] = d
        for di,dj in ((-1,-1),(-1,0),(-1,1),(1,-1),(1,0),(1,1),(0,-1),(0,1)): # 8방향 리스트(상왼, 상중간, 상오른, 하왼, 하중간, 하오른, 좌, 우)
            r = []
            for mul in range(1, N): # 1~ n-1 까지 뻗어나가는 거리(8방향)
                ni,nj = si+di*mul, sj+dj*mul # 다음 좌표계산
                if 1<=ni<=N and 1<=nj<=N: # 범위 내
                    if arr[ni][nj]==0: # 빈칸이면
                        break # 종료
                    elif arr[ni][nj]==d: # 같은 돌이면
                        while r: # 뒤집을 후보 배열에 좌표가 있다면
                            ti,tj = r.pop() # 배열에서 꺼낸 좌표를 뒤집을 좌표로 설정하고
                            arr[ti][tj]=d # 뒤집기
                        break
                    else: # 다른 돌이면 뒤집을 예정인 배열에 추가
                        r.append((ni,nj))
                else: # 범위 밖이면 종료
                    break
    # 2
    bcnt = wcnt = 0 # 흑돌, 백돌 초기화
    for lst in arr:
        bcnt += lst.count(1) # 흑돌 개수
        wcnt += lst.count(2) # 백돌 개수
 
    print(f'#{test_case} {bcnt} {wcnt}')

T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    table = [[0] * (N+1) for _ in range(N+1)] # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
    m = N // 2 # 중간 위치를 위해 중간 값
    # 1. 초기 돌 놓기
    table[m][m] = table[m+1][m+1] = 2 # 백돌 초기 돌 위치
    table[m][m+1] = table[m+1][m] = 1 # 흑 돌 초기 돌 위치

    # 2. 입력 받은 좌표에 돌 놓기 (8방향 뻗어나가면서 처리)
    for _ in range(M):
        start_i, start_j, color = map(int, input().split())
        table[start_i][start_j] = color
        for direction_i, direction_j in ((-1,-1), (-1,0), (-1,1), (1,-1), (1,0), (1,1), (0,-1), (0,1)): # 돌의 8가지 갈 수 있는 방향 선언
            change = [] # 색깔이 바뀔 예정인 돌의 좌표를 받는 리스트
            for distance in range(1, N):
                next_i, next_j = start_i + direction_i * distance,  start_j + direction_j * distance # 다음 좌표는 시작 좌표에 방향 좌표와 거리를 곱한 만큼을 더해줌
                # 3. 2번을 범위 내와 밖으로 나눠서 처리
                if 1 <= next_i <= N and 1 <= next_j <= N: # 테이블 내일때
                    # 5. 범위 내는 (1) 빈칸이 0이면 끝내고 다음방향 (2) 놓은 돌과 다른 돌이면 뒤집을 후보에 추가(reverse 배열) 하고 다음 방향 (3) 같은 돌이면 뒤집을 후보들 다 뒤집고 다음 방향
                    if table[next_i][next_j] == 0: # 다음 좌표가 빈칸이면 종료
                        break 
                    elif table[next_i][next_j] == color: # 다음 좌표가 같은 색깔이면
                        while change: # 색을 바꿀 좌표가 있으면
                            ci, cj = change.pop() # 배열에서 뺀 좌표를 
                            table[ci][cj] = color # 같은 색깔로 바꿔준다
                        break # 종료

                    else: # 색깔이 다르면
                        change.append((next_i, next_j)) # 색을 바꿀 예정 목록에 좌표를 넣어준다 
                # 4. 범위 밖은 아무일도 일어나지 않고 return
                else: # 테이블 범위 밖이면
                    break # 종료

    black_cnt = 0
    white_cnt = 0
    for stone in table: # 각 색깔의 돌 개수 세서 반환
        black_cnt += stone.count(1)
        white_cnt += stone.count(2)

    print("#{} {} {}".format(test_case, black_cnt, white_cnt))
